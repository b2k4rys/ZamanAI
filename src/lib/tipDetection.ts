import { Transaction } from "@/types/transaction";
import { Goal } from "@/types/goal";
import { Challenge } from "@/types/challenge";
import { Tip, TipType } from "@/types/tip";
import { differenceInDays, addDays, isSameDay } from "date-fns";
import { detectRecurringBills, estimateDaysToSalary, calculateAvgDailySpend, calculateBalance } from "./reminderDetection";

/**
 * Check if category has overspending
 */
export function detectCategoryOverspend(txns: Transaction[], category: string, thresholdPercent: number): number {
  const now = new Date();
  const currentMonth = txns.filter(t => {
    const d = new Date(t.date);
    return d.getMonth() === now.getMonth() && d.getFullYear() === now.getFullYear() && t.amount < 0;
  });
  
  const prevMonth = txns.filter(t => {
    const d = new Date(t.date);
    const prev = new Date(now.getFullYear(), now.getMonth() - 1, 1);
    return d.getMonth() === prev.getMonth() && d.getFullYear() === prev.getFullYear() && t.amount < 0;
  });

  const currentSpend = currentMonth
    .filter(t => t.category === category)
    .reduce((sum, t) => sum + Math.abs(t.amount), 0);
  
  const prevSpend = prevMonth
    .filter(t => t.category === category)
    .reduce((sum, t) => sum + Math.abs(t.amount), 0);

  if (prevSpend === 0) return 0;
  
  const delta = ((currentSpend - prevSpend) / prevSpend) * 100;
  return delta >= thresholdPercent ? delta : 0;
}

/**
 * Calculate free cash (balance - upcoming bills - goal targets)
 */
export function calculateFreeCash(txns: Transaction[], goals: Goal[]): number {
  const balance = calculateBalance(txns);
  const bills = detectRecurringBills(txns);
  const upcomingBills = bills.reduce((sum, b) => sum + b.amount, 0);
  const goalTargets = goals
    .filter(g => !g.status || g.status === 'active')
    .reduce((sum, g) => sum + ((Number(g.targetAmount) || 0) - (Number(g.savedAmount) || 0)) * 0.1, 0);
  
  return balance - upcomingBills - goalTargets;
}

/**
 * Detect duplicate subscriptions (same category, similar amounts)
 */
export function detectDuplicateSubs(txns: Transaction[]): { a: string; b: string } | null {
  const subscriptions = txns.filter(t => 
    t.amount < 0 && 
    (t.category === '–ü–æ–¥–ø–∏—Å–∫–∏' || t.note?.toLowerCase().includes('–ø–æ–¥–ø–∏—Å–∫–∞'))
  );

  const merchants = new Map<string, number>();
  subscriptions.forEach(t => {
    const m = t.merchant || '–ë–µ–∑ –Ω–∞–∑–≤–∞–Ω–∏—è';
    merchants.set(m, (merchants.get(m) || 0) + 1);
  });

  const recurring = Array.from(merchants.entries())
    .filter(([_, count]) => count >= 2)
    .map(([m, _]) => m);

  if (recurring.length >= 2) {
    return { a: recurring[0], b: recurring[1] };
  }

  return null;
}

/**
 * Generate smart tips based on customer data
 */
export function generateSmartTips(
  txns: Transaction[],
  goals: Goal[],
  challenges: Challenge[]
): Tip[] {
  const tips: Tip[] = [];
  const now = new Date().toISOString();
  const today = new Date();

  // 1. Upcoming bills
  const bills = detectRecurringBills(txns);
  bills.forEach(bill => {
    const daysUntil = differenceInDays(new Date(bill.nextDate), today);
    if (daysUntil <= 1 && daysUntil >= 0) {
      tips.push({
        id: `tip_bill_${bill.merchant}_${bill.nextDate}`,
        type: 'bill_upcoming',
        title: daysUntil === 0 ? `–°–µ–≥–æ–¥–Ω—è —Å–ø–∏—Å–∞–Ω–∏–µ –∑–∞ ${bill.merchant}` : `–ó–∞–≤—Ç—Ä–∞ —Å–ø–∏—Å–∞–Ω–∏–µ –∑–∞ ${bill.merchant}`,
        body: `${daysUntil === 0 ? '–°–µ–≥–æ–¥–Ω—è' : '–ó–∞–≤—Ç—Ä–∞'} —Å–ø–∏—Å–∞–Ω–∏–µ –∑–∞ **${bill.merchant}** –Ω–∞ **${bill.amount.toLocaleString('ru-KZ')} ‚Ç∏**. –ü–µ—Ä–µ–≤–µ–¥—É –∑–∞—Ä–∞–Ω–µ–µ?`,
        ts: now,
        actions: [
          { label: '–û–ø–ª–∞—Ç–∏—Ç—å', action: { kind: 'pay_bill', merchant: bill.merchant, amount: bill.amount } },
          { label: '–ù–∞–ø–æ–º–Ω–∏—Ç—å –∑–∞–≤—Ç—Ä–∞', action: { kind: 'snooze', hours: 24 } }
        ],
        priority: 9,
      });
    }
  });

  // 2. Low balance
  const balance = calculateBalance(txns);
  const daysToSalary = estimateDaysToSalary(txns);
  const avgDaily = calculateAvgDailySpend(txns);

  if (daysToSalary > 0 && balance > 0) {
    const dailyBudget = balance / daysToSalary;
    if (dailyBudget < avgDaily * 0.7) {
      tips.push({
        id: `tip_lowbal_${today.toISOString().split('T')[0]}`,
        type: 'low_balance',
        title: `–û—Å—Ç–∞—Ç–æ–∫ ${balance.toLocaleString('ru-KZ')} ‚Ç∏ –Ω–∞ ${daysToSalary} –¥–Ω`,
        body: `–û—Å—Ç–∞–ª–æ—Å—å **${balance.toLocaleString('ru-KZ')} ‚Ç∏** –Ω–∞ **${daysToSalary} –¥–Ω–µ–π**. –°—Ä–µ–¥–Ω–∏–π –¥–Ω–µ–≤–Ω–æ–π –±—é–¥–∂–µ—Ç: **${Math.round(dailyBudget).toLocaleString('ru-KZ')} ‚Ç∏** (–æ–±—ã—á–Ω–æ —Ç—Ä–∞—Ç–∏—Ç–µ ${Math.round(avgDaily).toLocaleString('ru-KZ')} ‚Ç∏). –†–∞—Å–ø—Ä–µ–¥–µ–ª–∏–º?`,
        ts: now,
        actions: [
          { label: '–†–∞—Å–ø—Ä–µ–¥–µ–ª–∏—Ç—å –±—é–¥–∂–µ—Ç', action: { kind: 'open_budget_planner' } },
          { label: '–ü–æ–∑–∂–µ', action: { kind: 'snooze', hours: 24 } }
        ],
        priority: 8,
      });
    }
  }

  // 3. Category overspend
  const categories = ['–ï–¥–∞', '–¢—Ä–∞–Ω—Å–ø–æ—Ä—Ç', '–†–∞–∑–≤–ª–µ—á–µ–Ω–∏—è', '–ü–æ–∫—É–ø–∫–∏', '–ü–æ–¥–ø–∏—Å–∫–∏'];
  categories.forEach(cat => {
    const delta = detectCategoryOverspend(txns, cat, 15);
    if (delta > 0) {
      tips.push({
        id: `tip_overspend_${cat}_${today.toISOString().split('T')[0]}`,
        type: 'overspend',
        title: `${cat}: —Ä–æ—Å—Ç –Ω–∞ ${delta.toFixed(0)}%`,
        body: `–ö–∞—Ç–µ–≥–æ—Ä–∏—è **${cat}** –≤—ã—Ä–æ—Å–ª–∞ –Ω–∞ **${delta.toFixed(0)}%** –æ—Ç–Ω–æ—Å–∏—Ç–µ–ª—å–Ω–æ –ø—Ä–æ—à–ª–æ–≥–æ –º–µ—Å—è—Ü–∞. –•–æ—á–µ—à—å —É—Å—Ç–∞–Ω–æ–≤–∏—Ç—å –ª–∏–º–∏—Ç –∏–ª–∏ —Å–æ–∑–¥–∞—Ç—å —á–µ–ª–ª–µ–Ω–¥–∂ –¥–ª—è –∫–æ–Ω—Ç—Ä–æ–ª—è?`,
        ts: now,
        actions: [
          { label: '–°–æ–∑–¥–∞—Ç—å —á–µ–ª–ª–µ–Ω–¥–∂', action: { kind: 'create_challenge', scope: { kind: 'category', value: cat } } },
          { label: '–ü–æ–∑–∂–µ', action: { kind: 'snooze', hours: 48 } }
        ],
        priority: 6,
      });
    }
  });

  // 4. Saving opportunity
  const freeCash = calculateFreeCash(txns, goals);
  if (freeCash > 30000) {
    tips.push({
      id: `tip_saving_${today.toISOString().split('T')[0]}`,
      type: 'saving_opportunity',
      title: `–°–≤–æ–±–æ–¥–Ω–æ ~${Math.round(freeCash).toLocaleString('ru-KZ')} ‚Ç∏`,
      body: `–õ–µ–∂–∏—Ç —Å–≤–æ–±–æ–¥–Ω–æ –ø—Ä–∏–º–µ—Ä–Ω–æ **${Math.round(freeCash).toLocaleString('ru-KZ')} ‚Ç∏**. –ú–æ–∂–µ–º –ø–µ—Ä–µ–≤–µ—Å—Ç–∏ —á–∞—Å—Ç—å –Ω–∞ —Ö–∞–ª—è–ª—å-–¥–µ–ø–æ–∑–∏—Ç –ø–æ–¥ 15% –≥–æ–¥–æ–≤—ã—Ö?`,
      ts: now,
      actions: [
        { label: '–ü–æ—Å–º–æ—Ç—Ä–µ—Ç—å –ø—Ä–æ–¥—É–∫—Ç—ã', action: { kind: 'open_budget_planner' } },
        { label: '–ü–æ–∑–∂–µ', action: { kind: 'snooze', hours: 72 } }
      ],
      priority: 5,
    });
  }

  // 5. Goal nudge
  const activeGoals = goals.filter(g => !g.status || g.status === 'active');
  activeGoals.forEach(goal => {
    const saved = Number(goal.savedAmount) || 0;
    const target = Number(goal.targetAmount) || 0;
    const progress = (saved / target) * 100;
    const monthlyPlan = Number(goal.monthlyPlan) || 0;
    
    // Calculate how much is missing this month
    const monthStart = new Date(today.getFullYear(), today.getMonth(), 1);
    const monthlyContributions = (goal.history || [])
      .filter(h => new Date(h.date) >= monthStart)
      .reduce((sum, h) => sum + (h.amount || 0), 0);
    
    const missing = monthlyPlan - monthlyContributions;
    
    if (progress < 80 && missing > 1000) {
      const suggested = Math.round(missing);
      tips.push({
        id: `tip_goal_${goal.id}_${today.toISOString().split('T')[0]}`,
        type: 'goal_nudge',
        title: `–î–æ —Ü–µ–ª–∏ "${goal.name}" –Ω–µ —Ö–≤–∞—Ç–∞–µ—Ç`,
        body: `–î–æ —Ü–µ–ª–∏ **¬´${goal.name}¬ª** –≤ —ç—Ç–æ–º –º–µ—Å—è—Ü–µ –Ω–µ –¥–æ–ª–æ–∂–µ–Ω–æ **${suggested.toLocaleString('ru-KZ')} ‚Ç∏** (–ø–ª–∞–Ω: ${monthlyPlan.toLocaleString('ru-KZ')} ‚Ç∏/–º–µ—Å). –ü–æ–ø–æ–ª–Ω–∏—Ç—å —Å–µ–π—á–∞—Å?`,
        ts: now,
        actions: [
          { label: '–ü–æ–ø–æ–ª–Ω–∏—Ç—å —Ü–µ–ª—å', action: { kind: 'transfer_to_goal', goalId: goal.id, amount: suggested } },
          { label: '–ü–æ–∑–∂–µ', action: { kind: 'snooze', hours: 48 } }
        ],
        priority: 7,
      });
    }
  });

  // 6. Challenge check-in
  const activeChallenges = challenges.filter(c => c.status === 'active');
  activeChallenges.forEach(challenge => {
    const todayCheckin = challenge.checkins.find(c => {
      const checkinDate = new Date(c.date);
      return checkinDate.getFullYear() === today.getFullYear() &&
             checkinDate.getMonth() === today.getMonth() &&
             checkinDate.getDate() === today.getDate();
    });

    if (!todayCheckin) {
      tips.push({
        id: `tip_challenge_${challenge.id}_${today.toISOString().split('T')[0]}`,
        type: 'challenge_checkin',
        title: `–ß–µ–∫-–∏–Ω –ø–æ "${challenge.title}"`,
        body: `–°–µ–≥–æ–¥–Ω—è —á–µ–∫-–∏–Ω –ø–æ —á–µ–ª–ª–µ–Ω–¥–∂—É **¬´${challenge.title}¬ª**. –£–∂–µ —Å–ø—Ä–∞–≤–∏–ª–∏—Å—å —Å –∑–∞–¥–∞—á–µ–π? –û—Ç–º–µ—Ç–∏–º! üåø`,
        ts: now,
        actions: [
          { label: '–ó–∞—Å—á–∏—Ç–∞—Ç—å —á–µ–∫-–∏–Ω', action: { kind: 'open_budget_planner' } },
          { label: '–ù–∞–ø–æ–º–Ω–∏—Ç—å –≤–µ—á–µ—Ä–æ–º', action: { kind: 'snooze', hours: 6 } }
        ],
        priority: 7,
      });
    }
  });

  // 7. Duplicate subscriptions
  const duplicates = detectDuplicateSubs(txns);
  if (duplicates) {
    tips.push({
      id: `tip_dupsubs_${today.toISOString().split('T')[0]}`,
      type: 'duplicate_subs',
      title: `–ü–æ—Ö–æ–∂–∏–µ –ø–æ–¥–ø–∏—Å–∫–∏`,
      body: `–ó–∞–º–µ—á–µ–Ω—ã –¥–≤–µ –ø–æ—Ö–æ–∂–∏–µ –ø–æ–¥–ø–∏—Å–∫–∏: **${duplicates.a}** –∏ **${duplicates.b}**. –ú–æ–∂–µ—Ç, –æ–¥–Ω—É –∏–∑ –Ω–∏—Ö –æ—Ç–∫–ª—é—á–∏—Ç—å?`,
      ts: now,
      actions: [
        { label: '–ü–æ–∫–∞–∑–∞—Ç—å –ø–æ–¥–ø–∏—Å–∫–∏', action: { kind: 'open_subscriptions' } },
        { label: '–ò–≥–Ω–æ—Ä–∏—Ä–æ–≤–∞—Ç—å', action: { kind: 'snooze', hours: 168 } } // week
      ],
      priority: 4,
    });
  }

  // Sort by priority and return top tips
  return tips.sort((a, b) => b.priority - a.priority).slice(0, 5);
}
